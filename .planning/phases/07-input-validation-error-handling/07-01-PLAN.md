# Phase 7 Plan 1: Input Validation & Error Handling

<objective>
Strengthen input validation across all API endpoints, improve error messages for users, and add comprehensive validation middleware using Zod schemas. This phase hardens the application for production by preventing bad data, providing clear user feedback, and ensuring security best practices.
</objective>

<execution_context>
## What We're Building

**Core Feature**: Production-grade input validation and user-friendly error handling

**Current State** (from Phase 6):
- ✅ Basic validation exists: wallet addresses, prices, transaction hashes
- ✅ SQL injection prevention (field whitelist in updateJobStatus)
- ✅ XSS prevention (HTML escaping from Phase 2/5)
- ❌ Validation inconsistent across endpoints
- ❌ Error messages expose implementation details
- ❌ No centralized validation logic
- ❌ Missing validation on several endpoints
- ❌ No request body size limits
- ❌ No UUID format validation

**Current Validation** (src/hub.js:14-24):
```javascript
function isValidEthereumAddress(address) {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}

function isValidPrice(price) {
  const num = Number(price);
  return !isNaN(num) && num > 0 && num < 1000; // Max $1000 per job
}
```

**Target State**:
- Comprehensive validation on ALL endpoints
- User-friendly error messages (no stack traces, implementation details)
- Centralized validation schemas (Zod)
- Consistent error response format
- Request body size limits
- UUID, URL, and other format validations

**Why This Matters**: Production hardening. Prevents security issues, data corruption, and provides better user experience through clear error messages.
</execution_context>

<context>
## Project Context

**Tech Stack**:
- Backend: Node.js + Express
- Validation Library: Zod (already installed: zod@^3.25.76)
- Database: PostgreSQL via pg (parameterized queries)
- Current validation: Manual checks in endpoint handlers

**API Endpoints to Validate**:
1. POST /api/users (wallet)
2. POST /api/jobs (wallet, agentId, skillId, input, price)
3. POST /api/jobs/:uuid/pay (txHash)
4. POST /api/jobs/:uuid/complete (apiKey, output)
5. POST /api/register-agent (wallet, name, webhookUrl)
6. GET endpoints with params (:id, :uuid, :wallet)

**Validation Requirements**:
- **Wallet addresses**: 0x + 40 hex chars (already implemented)
- **Prices**: Positive numbers, max $1000, match skill price
- **Agent/Skill IDs**: Positive integers, exist in database
- **Transaction hashes**: 0x + 64 hex chars
- **UUIDs**: Valid UUID v4 format
- **URLs (webhook_url)**: Valid HTTPS URLs
- **API keys**: Non-empty strings, min 32 chars
- **Input data**: Max size 10KB, required fields
- **Output data**: Valid JSON, max size 100KB

**Error Response Format** (standardize):
```javascript
{
  "error": "User-friendly message",
  "code": "INVALID_WALLET_ADDRESS",
  "details": { field: "wallet", provided: "0x123..." }
}
```

**Key Files**:
- `src/hub.js:14-24` — Current validation helpers
- `src/hub.js` — All API endpoints
- `src/db.js:231-263` — updateJobStatus (SQL injection already fixed)
- `package.json` — Zod already installed

## Recent Work (Phases 1-6)

**Phase 2**: Initial security hardening
- XSS prevention (HTML escaping, CSP header)
- SQL injection fix (field whitelist)
- Basic wallet/price validation

**Phase 6**: Webhook system
- API key validation for agent callbacks
- Webhook URL handling (needs HTTPS validation)

**Gaps Remaining**:
- Inconsistent validation across endpoints
- Missing database existence checks (agent/skill IDs)
- Error messages expose internals
- No UUID format validation
- No webhook URL validation (should be HTTPS)
- No request body size limits

## Success Criteria

### Functional
- [ ] All API endpoints have comprehensive validation
- [ ] User-friendly error messages (no stack traces)
- [ ] Consistent error response format
- [ ] Database existence checks for foreign keys
- [ ] Request body size limits enforced
- [ ] UUID format validation
- [ ] Webhook URL validation (HTTPS only)

### Security
- [ ] No SQL injection vulnerabilities
- [ ] No XXE or other injection attacks
- [ ] API key format validation
- [ ] Transaction hash format validation
- [ ] Input sanitization

### User Experience
- [ ] Clear, actionable error messages
- [ ] Field-level validation feedback
- [ ] HTTP status codes correct (400 for validation, 404 for not found, 401 for auth)
- [ ] No exposed implementation details

### Technical
- [ ] Centralized validation logic (src/validation.js)
- [ ] Zod schemas for all request bodies
- [ ] Validation middleware reusable
- [ ] No breaking changes to API contracts
</context>

<tasks>

## Task 1: Create Centralized Validation Module

**Objective**: Build validation module with Zod schemas and helper functions

**Why First**: Centralize validation logic, create reusable schemas

**Implementation**:

**File**: Create `src/validation.js` (new file)

**Code to Add**:
```javascript
const { z } = require('zod');

// ============================================
// ZOD SCHEMAS
// ============================================

// Ethereum address (0x + 40 hex chars)
const ethereumAddressSchema = z.string()
  .regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid Ethereum address format');

// Transaction hash (0x + 64 hex chars)
const txHashSchema = z.string()
  .regex(/^0x[a-fA-F0-9]{64}$/, 'Invalid transaction hash format');

// UUID v4
const uuidSchema = z.string()
  .uuid('Invalid UUID format');

// HTTPS URL
const httpsUrlSchema = z.string()
  .url('Invalid URL format')
  .refine(url => url.startsWith('https://'), 'Webhook URL must use HTTPS');

// Price (positive number, max $1000)
const priceSchema = z.number()
  .positive('Price must be positive')
  .max(1000, 'Price cannot exceed $1000');

// Positive integer ID
const positiveIdSchema = z.number()
  .int('ID must be an integer')
  .positive('ID must be positive');

// API key (min 32 chars)
const apiKeySchema = z.string()
  .min(32, 'Invalid API key format');

// Job input (max 10KB as string)
const jobInputSchema = z.union([
  z.string().max(10000, 'Input text too large (max 10KB)'),
  z.object({}).passthrough() // Allow objects
]).refine(
  (val) => {
    const size = JSON.stringify(val).length;
    return size <= 10000;
  },
  'Input data too large (max 10KB)'
);

// Job output (max 100KB)
const jobOutputSchema = z.object({}).passthrough()
  .refine(
    (val) => {
      const size = JSON.stringify(val).length;
      return size <= 100000;
    },
    'Output data too large (max 100KB)'
  );

// ============================================
// REQUEST SCHEMAS
// ============================================

const createUserSchema = z.object({
  wallet: ethereumAddressSchema
});

const createJobSchema = z.object({
  wallet: ethereumAddressSchema,
  agentId: positiveIdSchema,
  skillId: positiveIdSchema,
  input: jobInputSchema,
  price: priceSchema
});

const payJobSchema = z.object({
  txHash: txHashSchema
});

const completeJobSchema = z.object({
  apiKey: apiKeySchema,
  output: z.union([
    jobOutputSchema,
    z.undefined() // Allow missing output for status updates
  ]),
  status: z.enum(['in_progress', 'completed']).optional()
});

const registerAgentSchema = z.object({
  wallet: ethereumAddressSchema,
  name: z.string().min(1, 'Name is required').max(100, 'Name too long (max 100 chars)'),
  webhookUrl: z.union([
    httpsUrlSchema,
    z.null(),
    z.undefined()
  ]).optional()
});

// ============================================
// VALIDATION MIDDLEWARE
// ============================================

/**
 * Create Express middleware for validating request body
 * @param {z.ZodSchema} schema - Zod schema to validate against
 * @returns {Function} Express middleware
 */
function validateBody(schema) {
  return (req, res, next) => {
    try {
      const validated = schema.parse(req.body);
      req.validatedBody = validated; // Store validated data
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        // Format Zod errors into user-friendly response
        const firstError = error.errors[0];
        return res.status(400).json({
          error: firstError.message,
          code: 'VALIDATION_ERROR',
          field: firstError.path.join('.'),
          details: error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        });
      }
      next(error);
    }
  };
}

/**
 * Validate UUID parameter
 */
function validateUuidParam(paramName = 'uuid') {
  return (req, res, next) => {
    try {
      uuidSchema.parse(req.params[paramName]);
      next();
    } catch (error) {
      return res.status(400).json({
        error: 'Invalid job ID format',
        code: 'INVALID_UUID'
      });
    }
  };
}

/**
 * Validate positive integer ID parameter
 */
function validateIdParam(paramName = 'id') {
  return (req, res, next) => {
    const id = parseInt(req.params[paramName], 10);
    if (isNaN(id) || id <= 0) {
      return res.status(400).json({
        error: `Invalid ${paramName} format`,
        code: 'INVALID_ID'
      });
    }
    req.params[paramName] = id; // Store parsed integer
    next();
  };
}

// ============================================
// HELPER FUNCTIONS (backward compatibility)
// ============================================

function isValidEthereumAddress(address) {
  return ethereumAddressSchema.safeParse(address).success;
}

function isValidPrice(price) {
  return priceSchema.safeParse(price).success;
}

function isValidTxHash(hash) {
  return txHashSchema.safeParse(hash).success;
}

function isValidUuid(uuid) {
  return uuidSchema.safeParse(uuid).success;
}

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Schemas
  ethereumAddressSchema,
  txHashSchema,
  uuidSchema,
  httpsUrlSchema,
  priceSchema,
  positiveIdSchema,
  apiKeySchema,
  jobInputSchema,
  jobOutputSchema,

  // Request schemas
  createUserSchema,
  createJobSchema,
  payJobSchema,
  completeJobSchema,
  registerAgentSchema,

  // Middleware
  validateBody,
  validateUuidParam,
  validateIdParam,

  // Helper functions (backward compat)
  isValidEthereumAddress,
  isValidPrice,
  isValidTxHash,
  isValidUuid
};
```

**Verification**:
- Module exports all schemas and middleware
- Backward compatible with existing helper functions
- No dependencies on other modules (pure validation)

**Deliverable**:
- src/validation.js created (~250 lines)
- Zod schemas for all request types
- Validation middleware functions
- Helper functions for backward compatibility

**Commit**: `feat(07-01): create centralized validation module with Zod schemas`

---

## Task 2: Add Database Existence Validators

**Objective**: Create validators that check if agent/skill/user IDs exist in database

**Why Second**: Foreign key validation before business logic

**Implementation**:

**File**: `src/validation.js` (add to exports section)

**Code to Add**:
```javascript
const db = require('./db');

// ============================================
// DATABASE EXISTENCE VALIDATORS
// ============================================

/**
 * Validate that agent exists in database
 */
async function validateAgentExists(agentId) {
  const agent = await db.getAgent(agentId);
  if (!agent) {
    throw new Error('Agent not found');
  }
  return agent;
}

/**
 * Validate that skill exists in database
 */
async function validateSkillExists(skillId) {
  const skill = await db.getSkill(skillId);
  if (!skill) {
    throw new Error('Skill not found');
  }
  return skill;
}

/**
 * Validate that user exists in database
 */
async function validateUserExists(wallet) {
  const user = await db.getUser(wallet);
  if (!user) {
    throw new Error('User not found. Please create an account first.');
  }
  return user;
}

/**
 * Validate that skill belongs to agent
 */
async function validateSkillBelongsToAgent(skillId, agentId) {
  const skill = await db.getSkill(skillId);
  if (!skill) {
    throw new Error('Skill not found');
  }
  if (skill.agent_id !== agentId) {
    throw new Error('Skill does not belong to specified agent');
  }
  return skill;
}

/**
 * Validate that skill price matches expected price
 */
async function validateSkillPrice(skillId, expectedPrice) {
  const skill = await db.getSkill(skillId);
  if (!skill) {
    throw new Error('Skill not found');
  }

  const skillPrice = parseFloat(skill.price_usdc);
  const providedPrice = parseFloat(expectedPrice);

  // Allow 0.1% tolerance for floating point precision
  const tolerance = skillPrice * 0.001;
  if (Math.abs(skillPrice - providedPrice) > tolerance) {
    throw new Error(`Price mismatch. Expected $${skillPrice.toFixed(2)}, got $${providedPrice.toFixed(2)}`);
  }

  return skill;
}

// Add to exports
module.exports = {
  // ... existing exports ...

  // Database validators
  validateAgentExists,
  validateSkillExists,
  validateUserExists,
  validateSkillBelongsToAgent,
  validateSkillPrice
};
```

**Verification**:
- Validators throw descriptive errors
- Can be awaited in async handlers
- Don't expose internal database structure

**Deliverable**:
- Database existence validators added
- Price validation with tolerance
- Relationship validators (skill belongs to agent)

**Commit**: `feat(07-01): add database existence validators`

---

## Task 3: Apply Validation Middleware to API Endpoints

**Objective**: Add validation middleware to all API endpoints in hub.js

**Why Third**: Enforce validation at the API boundary

**Implementation**:

**File**: `src/hub.js`

**Add Import** (top of file, after existing requires):
```javascript
const {
  validateBody,
  validateUuidParam,
  validateIdParam,
  createUserSchema,
  createJobSchema,
  payJobSchema,
  completeJobSchema,
  registerAgentSchema,
  validateAgentExists,
  validateSkillExists,
  validateUserExists,
  validateSkillPrice
} = require('./validation');
```

**Update Endpoints** (add middleware before handlers):

**1. POST /api/users** (around line 1760):
```javascript
// Before (current):
router.post('/api/users', async (req, res) => {
  try {
    const { wallet } = req.body;
    // ...

// After (with validation):
router.post('/api/users', validateBody(createUserSchema), async (req, res) => {
  try {
    const { wallet } = req.validatedBody; // Use validated data
    // ... rest of handler unchanged
```

**2. POST /api/jobs** (around line 1773):
```javascript
// Add middleware and database validation
router.post('/api/jobs', validateBody(createJobSchema), async (req, res) => {
  try {
    const { wallet, agentId, skillId, input, price } = req.validatedBody;

    // Remove old manual validation (lines 1777-1800), replace with:

    // Validate user exists
    const user = await validateUserExists(wallet);

    // Validate agent exists
    await validateAgentExists(agentId);

    // Validate skill exists and belongs to agent
    await validateSkillBelongsToAgent(skillId, agentId);

    // Validate price matches skill price
    await validateSkillPrice(skillId, price);

    // Create job (rest of handler unchanged)
    const jobUuid = uuidv4();
    const job = await db.createJob(jobUuid, user.id, agentId, skillId, { prompt: input }, price);

    res.json({ jobUuid: job.job_uuid, status: job.status });
  } catch (error) {
    // Better error handling
    if (error.message.includes('not found') || error.message.includes('mismatch')) {
      return res.status(400).json({ error: error.message });
    }
    console.error('Job creation error:', error);
    res.status(500).json({ error: 'Failed to create job' });
  }
});
```

**3. POST /api/jobs/:uuid/pay** (around line 1822):
```javascript
router.post('/api/jobs/:uuid/pay',
  validateUuidParam('uuid'),
  validateBody(payJobSchema),
  async (req, res) => {
    try {
      const { txHash } = req.validatedBody;

      // Remove manual validation (lines 1826-1829)
      // Continue with rest of handler...
```

**4. POST /api/jobs/:uuid/complete** (around line 2070):
```javascript
router.post('/api/jobs/:uuid/complete',
  validateUuidParam('uuid'),
  validateBody(completeJobSchema),
  async (req, res) => {
    try {
      const { apiKey, output, status } = req.validatedBody;

      // Remove manual validation (lines 2075-2110)
      // Continue with rest of handler...
```

**5. POST /api/register-agent** (around line 2212):
```javascript
router.post('/api/register-agent', validateBody(registerAgentSchema), async (req, res) => {
  try {
    const { wallet, name, webhookUrl } = req.validatedBody;

    // Remove manual validation, continue with handler...
```

**6. GET endpoints with :id/:uuid params**:
```javascript
// GET /agent/:id
router.get('/agent/:id', validateIdParam('id'), async (req, res) => {
  // req.params.id is now validated and parsed as integer

// GET /job/:uuid
router.get('/job/:uuid', validateUuidParam('uuid'), async (req, res) => {
  // req.params.uuid is now validated

// GET /api/agents/:id/jobs
router.get('/api/agents/:id/jobs', validateIdParam('id'), async (req, res) => {
  // Validated
```

**Remove Old Validation Functions** (lines 14-24):
```javascript
// DELETE these (now in validation.js):
function isValidEthereumAddress(address) { ... }
function isValidPrice(price) { ... }
```

**Verification**:
- All endpoints have validation middleware
- Validated data accessed via req.validatedBody
- Old manual validation removed
- Error handling improved

**Deliverable**:
- All API endpoints use validation middleware
- Database existence checks in job creation
- Consistent error responses
- Old validation helpers removed

**Commit**: `feat(07-01): apply validation middleware to all API endpoints`

---

## Task 4: Improve Error Messages and Response Format

**Objective**: Standardize error responses and make messages user-friendly

**Why Fourth**: Better user experience, consistent API responses

**Implementation**:

**File**: `src/hub.js`

**Create Error Handler Middleware** (add near top of file, after imports):
```javascript
// ============================================
// ERROR HANDLING
// ============================================

/**
 * Format error response consistently
 */
function formatErrorResponse(error, defaultMessage = 'An error occurred') {
  // Don't expose internal errors in production
  const isProduction = process.env.NODE_ENV === 'production';

  // Known error types
  if (error.message.includes('not found')) {
    return {
      statusCode: 404,
      body: {
        error: error.message,
        code: 'NOT_FOUND'
      }
    };
  }

  if (error.message.includes('Invalid') || error.message.includes('mismatch')) {
    return {
      statusCode: 400,
      body: {
        error: error.message,
        code: 'INVALID_INPUT'
      }
    };
  }

  if (error.message.includes('unauthorized') || error.message.includes('API key')) {
    return {
      statusCode: 403,
      body: {
        error: 'Unauthorized',
        code: 'UNAUTHORIZED'
      }
    };
  }

  // Generic errors
  console.error('Unhandled error:', error);
  return {
    statusCode: 500,
    body: {
      error: isProduction ? defaultMessage : error.message,
      code: 'INTERNAL_ERROR'
    }
  };
}

/**
 * Express error handler middleware
 */
function errorHandler(err, req, res, next) {
  const { statusCode, body } = formatErrorResponse(err);
  res.status(statusCode).json(body);
}
```

**Update All Endpoint Error Handling**:

Replace generic catch blocks with:
```javascript
// OLD:
} catch (error) {
  console.error('Error:', error);
  res.status(500).json({ error: error.message });
}

// NEW:
} catch (error) {
  const { statusCode, body } = formatErrorResponse(error, 'Failed to process request');
  res.status(statusCode).json(body);
}
```

**Add Global Error Handler** (at end of file, before module.exports):
```javascript
// Global error handler (catch-all for unhandled errors)
router.use(errorHandler);
```

**Update Specific Error Messages**:

**Job Creation** (src/hub.js ~line 1815):
```javascript
// OLD:
return res.status(500).json({ error: error.message });

// NEW:
return res.status(400).json({
  error: 'Unable to create job. Please check your inputs and try again.',
  code: 'JOB_CREATION_FAILED'
});
```

**Payment Verification** (src/hub.js ~line 1864):
```javascript
// OLD:
return res.status(400).json({
  error: 'Payment verification failed',
  details: verification.error
});

// NEW:
return res.status(400).json({
  error: 'Payment could not be verified. Please ensure you sent the correct amount to the right address.',
  code: 'PAYMENT_VERIFICATION_FAILED',
  details: verification.error
});
```

**Verification**:
- Error responses consistent across all endpoints
- No stack traces or internal details exposed
- Appropriate HTTP status codes
- User-friendly error messages

**Deliverable**:
- formatErrorResponse() helper function
- Global error handler middleware
- All endpoints use consistent error format
- User-friendly error messages

**Commit**: `feat(07-01): improve error messages and standardize response format`

---

## Task 5: Add Request Body Size Limits

**Objective**: Prevent DOS attacks via large request bodies

**Why Fifth**: Security hardening, prevent resource exhaustion

**Implementation**:

**File**: `src/index.js`

**Current** (line 11):
```javascript
app.use(express.json({ limit: '10mb' }));
```

**Update to**:
```javascript
// More restrictive limits for API endpoints
app.use(express.json({
  limit: '100kb', // Default limit for most requests
  strict: true,   // Only accept arrays and objects
}));

// Specific limit for job completion (agents posting results)
app.use('/api/jobs/:uuid/complete', express.json({
  limit: '500kb' // Allow larger output data from agents
}));
```

**Add Request Size Validator Middleware** (src/validation.js):
```javascript
/**
 * Validate request body size doesn't exceed limit
 */
function validateRequestSize(maxSizeKB = 100) {
  return (req, res, next) => {
    const contentLength = req.headers['content-length'];
    if (contentLength && parseInt(contentLength, 10) > maxSizeKB * 1024) {
      return res.status(413).json({
        error: `Request body too large (max ${maxSizeKB}KB)`,
        code: 'PAYLOAD_TOO_LARGE'
      });
    }
    next();
  };
}

// Add to exports
module.exports = {
  // ... existing exports ...
  validateRequestSize
};
```

**Apply to Specific Endpoints** (src/hub.js):
```javascript
const { validateRequestSize } = require('./validation');

// Job creation with input data
router.post('/api/jobs',
  validateRequestSize(50), // 50KB limit for job inputs
  validateBody(createJobSchema),
  async (req, res) => { ... });

// Agent completion with output data
router.post('/api/jobs/:uuid/complete',
  validateRequestSize(500), // 500KB limit for job outputs
  validateUuidParam('uuid'),
  validateBody(completeJobSchema),
  async (req, res) => { ... });
```

**Verification**:
- Request body size limits enforced
- Large requests rejected before parsing
- Clear error messages for size violations

**Deliverable**:
- Express JSON parser with size limits
- validateRequestSize() middleware
- Size limits on job creation and completion endpoints

**Commit**: `feat(07-01): add request body size limits for security`

---

## Task 6: Add Input Sanitization and Final Hardening

**Objective**: Sanitize text inputs, add final security checks

**Why Sixth**: Defense in depth, prevent edge cases

**Implementation**:

**File**: `src/validation.js` (add sanitization helpers)

**Code to Add**:
```javascript
// ============================================
// SANITIZATION HELPERS
// ============================================

/**
 * Sanitize text input (trim, normalize whitespace)
 */
function sanitizeText(text) {
  if (typeof text !== 'string') return text;
  return text.trim().replace(/\s+/g, ' ');
}

/**
 * Sanitize job input data
 */
function sanitizeJobInput(input) {
  if (typeof input === 'string') {
    return sanitizeText(input);
  }
  if (typeof input === 'object' && input !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(input)) {
      if (typeof value === 'string') {
        sanitized[key] = sanitizeText(value);
      } else {
        sanitized[key] = value;
      }
    }
    return sanitized;
  }
  return input;
}

/**
 * Validate and sanitize webhook URL
 */
function sanitizeWebhookUrl(url) {
  if (!url) return null;

  // Ensure HTTPS
  if (!url.startsWith('https://')) {
    throw new Error('Webhook URL must use HTTPS protocol');
  }

  // Validate URL format
  try {
    const parsed = new URL(url);

    // Don't allow localhost/private IPs in production
    if (process.env.NODE_ENV === 'production') {
      const hostname = parsed.hostname;
      if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('192.168.') || hostname.startsWith('10.')) {
        throw new Error('Webhook URL cannot use private/local addresses');
      }
    }

    return url.trim();
  } catch (error) {
    throw new Error('Invalid webhook URL format');
  }
}

// Add to exports
module.exports = {
  // ... existing exports ...
  sanitizeText,
  sanitizeJobInput,
  sanitizeWebhookUrl
};
```

**Apply Sanitization** (src/hub.js):

**Job Creation** (after validation):
```javascript
router.post('/api/jobs', validateBody(createJobSchema), async (req, res) => {
  try {
    const { wallet, agentId, skillId, input, price } = req.validatedBody;

    // Sanitize input before storing
    const sanitizedInput = sanitizeJobInput(input);

    // ... validation ...

    const jobUuid = uuidv4();
    const job = await db.createJob(jobUuid, user.id, agentId, skillId, { prompt: sanitizedInput }, price);
    // ...
```

**Agent Registration** (webhook URL):
```javascript
router.post('/api/register-agent', validateBody(registerAgentSchema), async (req, res) => {
  try {
    const { wallet, name, webhookUrl } = req.validatedBody;

    // Sanitize and validate webhook URL
    const sanitizedWebhookUrl = webhookUrl ? sanitizeWebhookUrl(webhookUrl) : null;
    const sanitizedName = sanitizeText(name);

    // ... rest of handler with sanitized values ...
```

**Add Environment Variable Validation** (src/index.js, in start() function):
```javascript
async function start() {
  // Validate required environment variables
  const required = [
    'DATABASE_URL',
    'ANTHROPIC_API_KEY',
    'ALCHEMY_API_KEY',
    'REPLICATE_API_TOKEN'
  ];

  const missing = required.filter(key => !process.env[key]);
  if (missing.length > 0) {
    console.error('Missing required environment variables:', missing.join(', '));
    process.exit(1);
  }

  try {
    await db.initDB();
    app.listen(PORT, () => {
      // ... existing startup log
    });
  } catch (error) {
    console.error('Failed to start:', error.message);
    process.exit(1);
  }
}
```

**Verification**:
- Text inputs trimmed and normalized
- Webhook URLs validated for HTTPS and format
- Environment variables checked on startup
- Private IPs blocked in production webhooks

**Deliverable**:
- Text sanitization helpers
- Webhook URL sanitization
- Environment variable validation
- Production safeguards for webhook URLs

**Commit**: `feat(07-01): add input sanitization and final hardening`

---

</tasks>

<verification>

## Pre-Execution Checklist

Before starting implementation:
- [ ] Phase 6 complete (webhook system working)
- [ ] Zod installed (verified: zod@^3.25.76)
- [ ] All API endpoints identified
- [ ] Current validation understood

## Post-Task Checkpoints

### After Task 1 (Validation Module)
- [ ] src/validation.js created
- [ ] Zod schemas for all request types
- [ ] Validation middleware functions
- [ ] Backward compatible helper functions

### After Task 2 (Database Validators)
- [ ] validateAgentExists() added
- [ ] validateSkillExists() added
- [ ] validateUserExists() added
- [ ] validateSkillPrice() with tolerance

### After Task 3 (Apply Middleware)
- [ ] All POST endpoints have validateBody()
- [ ] All :uuid params have validateUuidParam()
- [ ] All :id params have validateIdParam()
- [ ] Database validation in job creation
- [ ] Old validation helpers removed

### After Task 4 (Error Messages)
- [ ] formatErrorResponse() function
- [ ] Global error handler middleware
- [ ] Consistent error format across endpoints
- [ ] User-friendly messages (no internals)

### After Task 5 (Request Size Limits)
- [ ] Express JSON parser limited to 100KB default
- [ ] validateRequestSize() middleware
- [ ] Job completion allows 500KB
- [ ] Clear error for oversized requests

### After Task 6 (Sanitization)
- [ ] sanitizeText() function
- [ ] sanitizeJobInput() function
- [ ] sanitizeWebhookUrl() with HTTPS enforcement
- [ ] Environment variables validated on startup
- [ ] Private IPs blocked in production

## Final Verification Commands

```bash
# 1. Server starts successfully
npm start
# Expected: "Agent Economy Hub v0.9.0", no missing env var errors

# 2. Validation module loads
node -e "const v = require('./src/validation'); console.log(typeof v.validateBody)"
# Expected: "function"

# 3. Test invalid wallet address
curl -X POST http://localhost:7378/api/users \
  -H "Content-Type: application/json" \
  -d '{"wallet": "invalid"}'
# Expected: 400 with validation error

# 4. Test invalid price
curl -X POST http://localhost:7378/api/jobs \
  -H "Content-Type: application/json" \
  -d '{"wallet": "0x1234567890123456789012345678901234567890", "agentId": 1, "skillId": 1, "input": "test", "price": -5}'
# Expected: 400 with "Price must be positive" error

# 5. Test oversized request
curl -X POST http://localhost:7378/api/jobs \
  -H "Content-Type: application/json" \
  -d '{"wallet": "0x1234567890123456789012345678901234567890", "agentId": 1, "skillId": 1, "input": "'$(python3 -c 'print("x" * 60000)')'"}'
# Expected: 413 Payload too large

# 6. Test invalid UUID
curl http://localhost:7378/job/invalid-uuid
# Expected: 400 with "Invalid job ID format"
```

## Success Criteria (Final)

All must be true:
- [ ] All API endpoints have comprehensive validation
- [ ] Zod schemas validate all inputs
- [ ] Database existence checks prevent orphaned records
- [ ] Error messages user-friendly (no stack traces, no internals)
- [ ] Consistent error response format
- [ ] Request body size limits enforced
- [ ] Input sanitization prevents injection
- [ ] Webhook URLs validated for HTTPS
- [ ] Environment variables checked on startup
- [ ] No breaking changes to API contracts

</verification>

<success_criteria>

## Phase 7 Complete When:

### Functional Requirements ✅
1. **Comprehensive Validation**:
   - All API endpoints validate inputs
   - Zod schemas for all request bodies
   - UUID, wallet, price, URL format validation
   - Database existence checks (agent, skill, user)

2. **Error Handling**:
   - User-friendly error messages
   - Consistent error response format
   - Appropriate HTTP status codes (400, 401, 403, 404, 500)
   - No exposed implementation details

3. **Security**:
   - Request body size limits (100KB default, 500KB for completions)
   - Input sanitization (trim, normalize whitespace)
   - Webhook URL validation (HTTPS only, no private IPs in prod)
   - Environment variable validation on startup

### Technical Requirements ✅
1. **Code Quality**:
   - Centralized validation logic (src/validation.js)
   - Reusable validation middleware
   - Backward compatible helper functions
   - Clean separation of concerns

2. **Maintainability**:
   - Zod schemas easy to update
   - Validation errors clearly formatted
   - Consistent error handling patterns
   - Well-documented validation rules

3. **Performance**:
   - Validation happens at API boundary (early exit)
   - Database checks only when needed
   - Request size validation before parsing

### User Experience ✅
1. **Clear Feedback**:
   - Specific error messages ("Price must be positive")
   - Field-level validation feedback
   - Actionable error messages (what to fix)
   - No technical jargon in user-facing errors

2. **API Consistency**:
   - All endpoints follow same validation pattern
   - Error response format consistent
   - HTTP status codes meaningful
   - Validation errors structured

## Unblocks

Phase 7 completion unblocks:
- ✅ **Phase 8**: Mobile & UI Polish (validation UX in place)
- ✅ **Phase 12**: E2E Testing (validation can be tested)
- ✅ **Production Launch**: Security hardening complete

## Not In Scope (Deferred)

These are explicitly NOT part of Phase 7:
- ❌ Rate limiting (Phase 9)
- ❌ Advanced input validation (JSON schema beyond size)
- ❌ Custom validation rules per service
- ❌ Validation caching or memoization
- ❌ Validation performance optimization
- ❌ Async validation beyond database checks
- ❌ Multi-language error messages

</success_criteria>

<output>

## Deliverables

### Code Files Created
1. **src/validation.js** — Validation module (new, ~400 lines)
   - Zod schemas for all request types
   - Validation middleware (validateBody, validateUuidParam, validateIdParam)
   - Database existence validators
   - Sanitization helpers
   - Request size validator

### Code Files Modified
1. **src/hub.js** — API endpoints enhanced
   - Import validation module
   - Add validation middleware to all endpoints
   - Update error handling
   - Remove old validation helpers
   - Apply sanitization

2. **src/index.js** — Server startup
   - Update JSON parser limits
   - Add environment variable validation
   - Validate required env vars on startup

### User Experience Improvements
- Clear, actionable error messages
- Consistent error response format
- Field-level validation feedback
- No exposed implementation details
- Better HTTP status codes

### Security Enhancements
- Request body size limits
- Input sanitization
- Webhook URL validation (HTTPS only)
- Private IP blocking in production
- Environment variable validation

## Files to Commit

```bash
# Task 1
git add src/validation.js
git commit -m "feat(07-01): create centralized validation module with Zod schemas

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Task 2
git add src/validation.js
git commit -m "feat(07-01): add database existence validators

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Task 3
git add src/hub.js
git commit -m "feat(07-01): apply validation middleware to all API endpoints

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Task 4
git add src/hub.js
git commit -m "feat(07-01): improve error messages and standardize response format

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Task 5
git add src/index.js src/validation.js
git commit -m "feat(07-01): add request body size limits for security

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Task 6
git add src/validation.js src/hub.js src/index.js
git commit -m "feat(07-01): add input sanitization and final hardening

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

## Next Phase Preview

After Phase 7 completion, proceed to:

**Phase 8: Mobile Responsive & UI Polish**
- Mobile-responsive layouts (CSS media queries)
- Loading spinners for async operations
- Success/error toast notifications
- Better button states (disabled while loading)
- Consistent spacing and typography

**To start**: `/gsd:plan-phase 8`

</output>

---

**Estimated Time**: 2-3 hours
**Complexity**: Low-Medium (validation logic, middleware)
**Risk Level**: Low (validation improves stability)
**Dependencies**: Phase 6 complete, Zod installed

**Budget Impact**:
- Development: $0 (no API calls)
- Validation: Minimal performance overhead (<1ms per request)
- No external dependencies beyond Zod (already installed)

**Critical Success Factor**: No breaking changes to API contracts. All existing valid requests must continue to work.

---

*Plan created: 2026-02-03*
*Phase: 7 of 13*
*Mode: YOLO (auto-execute)*
