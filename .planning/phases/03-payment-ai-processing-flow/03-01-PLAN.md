# Phase 3 Plan 1: Payment → AI Processing Flow

<objective>
Wire the payment verification endpoint to immediately trigger AI job processing, call Claude with service-specific prompts, store results in the database, and update job status to completed. Enable complete end-to-end flow: user pays → AI generates → result delivered.
</objective>

<execution_context>
## What We're Building

**Core Flow**: After payment is verified on-chain (Phase 2), immediately process the job using the Anthropic Claude API, store the AI-generated result, and mark the job as completed.

**Current State** (from Phase 2):
- ✅ POST `/api/jobs/:uuid/pay` verifies transactions on-chain
- ✅ Payment amount and recipient validated
- ✅ Job status updated to "paid" after verification
- ❌ NO AI processing triggered
- ❌ Job sits in "paid" status forever
- ❌ `output_data` field remains NULL

**Target State**:
```
POST /api/jobs/:uuid/pay { txHash }
  ↓
1. Verify payment on-chain (already working)
2. Update status: pending → paid
3. ⭐ NEW: Fetch skill details from database
4. ⭐ NEW: Extract service key from skill
5. ⭐ NEW: Call generateWithAI(serviceKey, input)
6. ⭐ NEW: Store result in output_data
7. ⭐ NEW: Update status: paid → completed
8. Return success response
```

**Success**: User pays 0.50 USDC → receives AI brainstorm results in ~2 seconds
</execution_context>

<context>
## Project Context

**Tech Stack**:
- Backend: Node.js + Express
- AI: Claude Sonnet 4 via Anthropic SDK (@anthropic-ai/sdk)
- Database: PostgreSQL on Railway
- Existing AI Function: `generateWithAI(serviceKey, userMessage)` in src/index.js:146-174

**Key Files**:
- `src/hub.js:1567-1596` — Payment endpoint (needs AI integration)
- `src/index.js:146-174` — generateWithAI function (already works)
- `src/services.js` — Service catalog with prompts for 17 services
- `src/db.js` — Database helpers (need getSkill function)

**Database Schema**:
```sql
skills (
  id SERIAL PRIMARY KEY,
  agent_id INTEGER,
  name TEXT,           -- "Brainstorm", "Creative Concept", etc.
  description TEXT,
  category TEXT,       -- "creative", "research", etc.
  price_usdc NUMERIC,
  estimated_time TEXT,
  service_key TEXT,    -- ⚠️ ASSUMPTION: exists, maps to services.js keys
  is_active BOOLEAN,
  created_at TIMESTAMP
)

jobs (
  id SERIAL PRIMARY KEY,
  job_uuid TEXT UNIQUE,
  requester_id INTEGER,
  agent_id INTEGER,
  skill_id INTEGER,    -- References skills.id
  status TEXT,         -- "pending" | "paid" | "completed" | "failed"
  input_data JSONB,    -- { prompt: "user input..." }
  output_data JSONB,   -- ⭐ Store AI results here
  price_usdc NUMERIC,
  payment_tx_hash TEXT,
  created_at TIMESTAMP,
  paid_at TIMESTAMP,
  completed_at TIMESTAMP
)
```

**Services Mapping** (services.js → database):
- Database seed creates 17 skills for MrMagoochi agent
- Each skill has a `service_key` (e.g., "brainstorm", "concept", "research")
- Service key maps to `SERVICES` object in services.js
- Each service has a `systemPrompt` for Claude

**AI Function Signature**:
```javascript
async function generateWithAI(serviceKey, userMessage)
  → returns JSON object with structured output
  → throws error if service not found or AI fails
```

**Budget Constraint**: Minimize Anthropic API costs
- Each job costs ~$0.005-0.015 in API fees
- User pays $0.10-1.50 per job
- Healthy margin, but avoid unnecessary calls

## Recent Work (Phases 1-2)

**Phase 1** (Complete):
- Dependencies installed
- Environment configured (ANTHROPIC_API_KEY in .env)
- Database connected and seeded with 22 skills

**Phase 2** (Complete):
- Created `src/blockchain.js` for payment verification
- Payment endpoint verifies USDC transactions on Base network
- Validates amount (0.1% tolerance) and recipient
- Securely stores Alchemy API key server-side
- Input validation prevents injection attacks

**Unblocked By Phase 2**:
- Safe to process jobs after payment verification
- No risk of processing unpaid jobs
- Transaction hash stored for audit trail

## Known Constraints

1. **No Job Queue**: Direct inline processing (decision from PROJECT.md)
   - Simpler to implement
   - Sufficient for initial volume
   - Can add queue later if needed

2. **YOLO Mode**: Auto-execute without user confirmation
   - Fast iteration
   - No approval delays

3. **No Webhooks Yet**: Phase 6 will add agent notifications
   - For now, only MrMagoochi processes jobs
   - MrMagoochi's AI is server-side (no webhook needed)

## Discovered Issues

**CRITICAL**: Need to verify `service_key` column exists in skills table
- Schema documentation shows: `name`, `description`, `category`, `price_usdc`
- ⚠️ Does NOT explicitly mention `service_key` column
- **Discovery task needed**: Check if column exists or how to map skills → services

**Alternative Approaches** if service_key missing:
1. Add `service_key` column to skills table (migration)
2. Use skill `name` to infer service key (e.g., "Brainstorm" → "brainstorm")
3. Add mapping table or hardcoded lookup

## Success Criteria

### Functional
- [ ] Payment endpoint triggers AI generation after verification
- [ ] AI results stored in `jobs.output_data` (JSONB)
- [ ] Job status progresses: `pending` → `paid` → `completed`
- [ ] `paid_at` and `completed_at` timestamps populated
- [ ] User can view results on GET `/job/:uuid` page
- [ ] Error handling for AI failures (timeouts, API errors)

### Technical
- [ ] No breaking changes to existing payment flow
- [ ] Transaction committed only if ALL steps succeed
- [ ] Failed AI generation updates status to "failed"
- [ ] Error messages logged for debugging
- [ ] ~2-5 second end-to-end latency (payment verify → AI result)

### Verification
- [ ] Manual test: Create job → Pay → See results within 5 seconds
- [ ] Database check: `output_data` contains JSON with expected structure
- [ ] Error test: Invalid service key returns proper error
- [ ] Server logs show AI generation timing
</context>

<tasks>

## Task 1: Discovery — Verify Skill-to-Service Mapping

**Objective**: Determine how skills in the database map to service keys in services.js

**Why First**: Need to know the mapping strategy before implementing AI integration. If `service_key` column doesn't exist, need to add it or use alternative approach.

**Steps**:

1. **Check database schema for service_key column**:
   ```bash
   node -e "
   const db = require('./src/db');
   db.query('SELECT column_name, data_type FROM information_schema.columns WHERE table_name = \\'skills\\'')
     .then(r => console.log(r.rows))
     .catch(e => console.error(e));
   "
   ```

2. **Query existing skills to see what fields exist**:
   ```bash
   node -e "
   const db = require('./src/db');
   db.query('SELECT * FROM skills LIMIT 1')
     .then(r => console.log(r.rows[0]))
     .catch(e => console.error(e));
   "
   ```

3. **Check services.js keys**:
   ```bash
   node -e "
   const { SERVICES } = require('./src/services');
   console.log('Available service keys:', Object.keys(SERVICES));
   "
   ```

**Decision Matrix**:

| Finding | Action |
|---------|--------|
| `service_key` column exists | Use it directly (ideal) |
| No column, but skill names match | Add column via migration, update seed data |
| No obvious mapping | Create lookup function (name → key transformation) |

**Checkpoint**: Stop and report findings before proceeding to Task 2

**Deliverable**: Document the mapping approach in comments

---

## Task 2: Add Database Helper for Skill Lookup

**Objective**: Create `getSkill(skillId)` function in src/db.js to fetch skill details including service mapping

**Why Second**: Payment endpoint needs to fetch skill data to determine which AI service to call

**Implementation**:

**File**: `src/db.js`

**Location**: After `getSkillsByAgent` function (~line 180)

**Code**:
```javascript
async function getSkill(skillId) {
  const result = await query(
    'SELECT * FROM skills WHERE id = $1',
    [skillId]
  );
  return result.rows[0];
}
```

**If service_key column missing**, add migration:
```javascript
// Add to initDB() function in src/db.js before CREATE TABLE skills
await query(`
  ALTER TABLE skills
  ADD COLUMN IF NOT EXISTS service_key TEXT;
`);

// Update existing skills with service keys (run once)
await query(`
  UPDATE skills SET service_key = LOWER(REGEXP_REPLACE(name, '[^a-zA-Z0-9]', '', 'g'))
  WHERE service_key IS NULL;
`);
// This transforms "Brainstorm" → "brainstorm", "Creative Concept" → "creativeconcept"
```

**Export the function**:
```javascript
module.exports = {
  // ... existing exports
  getSkill,
};
```

**Verification**:
```bash
# Test the function
node -e "
const db = require('./src/db');
db.getSkill(1).then(skill => {
  console.log('Skill 1:', skill);
  console.log('Service key:', skill.service_key || 'MISSING');
});
"
```

**Checkpoint**: Verify function returns skill with valid service_key

**Deliverable**:
- `getSkill()` function in src/db.js
- Exported in module.exports
- Tested with database query

---

## Task 3: Integrate AI Processing into Payment Endpoint

**Objective**: Wire payment verification to trigger AI generation and store results

**Why Third**: Core integration that connects payment → processing → completion

**File**: `src/hub.js`

**Location**: POST `/api/jobs/:uuid/pay` endpoint (lines 1567-1596)

**Current Code** (simplified):
```javascript
router.post('/api/jobs/:uuid/pay', async (req, res) => {
  try {
    const { txHash } = req.body;

    // Validation...
    const job = await db.getJob(req.params.uuid);
    const agent = await db.getAgent(job.agent_id);

    // Verify payment on-chain
    const verification = await blockchain.verifyUSDCPayment(txHash, job.price_usdc, agentWallet);
    if (!verification.valid) {
      return res.status(400).json({ error: 'Payment verification failed' });
    }

    // Update job status to paid
    await db.updateJobStatus(job.id, 'paid', {
      payment_tx_hash: txHash,
      paid_at: new Date().toISOString()
    });

    res.json({ success: true });  // ⭐ STOPS HERE
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

**New Code** (add after payment verification):
```javascript
router.post('/api/jobs/:uuid/pay', async (req, res) => {
  try {
    const { txHash } = req.body;

    // [... existing validation and verification code ...]

    // Verify payment on-chain
    const verification = await blockchain.verifyUSDCPayment(txHash, job.price_usdc, agentWallet);
    if (!verification.valid) {
      return res.status(400).json({ error: 'Payment verification failed', details: verification.error });
    }

    // Update job status to paid
    await db.updateJobStatus(job.id, 'paid', {
      payment_tx_hash: txHash,
      paid_at: new Date().toISOString()
    });

    // ⭐ NEW: Process job with AI
    try {
      // Fetch skill to get service key
      const skill = await db.getSkill(job.skill_id);
      if (!skill) {
        throw new Error('Skill not found');
      }

      // Determine service key (use service_key column or derive from name)
      const serviceKey = skill.service_key || skill.name.toLowerCase().replace(/[^a-z0-9]/g, '');

      // Extract user's input from job data
      const userInput = job.input_data.prompt || job.input_data.input || JSON.stringify(job.input_data);

      // Call AI generation
      console.log(`[Job ${job.job_uuid}] Starting AI generation with service: ${serviceKey}`);
      const startTime = Date.now();

      const aiResult = await generateWithAI(serviceKey, userInput);

      const duration = Date.now() - startTime;
      console.log(`[Job ${job.job_uuid}] AI generation completed in ${duration}ms`);

      // Store result and mark completed
      await db.updateJobStatus(job.id, 'completed', {
        output_data: JSON.stringify(aiResult),
        completed_at: new Date().toISOString()
      });

      res.json({
        success: true,
        jobUuid: job.job_uuid,
        status: 'completed'
      });

    } catch (aiError) {
      // AI generation failed - mark job as failed
      console.error(`[Job ${job.job_uuid}] AI generation error:`, aiError.message);

      await db.updateJobStatus(job.id, 'failed', {
        output_data: JSON.stringify({
          error: 'AI generation failed',
          message: aiError.message
        }),
        completed_at: new Date().toISOString()
      });

      res.status(500).json({
        error: 'Job payment verified but AI processing failed',
        details: aiError.message,
        jobUuid: job.job_uuid
      });
    }

  } catch (error) {
    console.error('Payment endpoint error:', error.message);
    res.status(500).json({ error: error.message });
  }
});
```

**Import generateWithAI** at top of file:
```javascript
const { generateWithAI } = require('./index');  // ⚠️ Circular dependency issue
```

**⚠️ PROBLEM**: Circular dependency (hub.js imports index.js which imports hub.js)

**SOLUTION**: Move `generateWithAI` to separate file first

**Refactor Needed**:
1. Create `src/ai.js` with `generateWithAI` function
2. Update imports in both `src/index.js` and `src/hub.js`

**Checkpoint**: After refactor, verify payment endpoint compiles without circular dependency error

**Deliverable**:
- AI processing integrated into payment endpoint
- Error handling for AI failures
- Logging for debugging
- No circular dependencies

---

## Task 4: Extract generateWithAI to Separate Module

**Objective**: Move AI generation logic to `src/ai.js` to avoid circular dependencies

**Why Fourth**: Hub.js needs to call generateWithAI, but index.js imports hub.js router

**Create**: `src/ai.js`

**Code**:
```javascript
// src/ai.js
// AI Generation Module - Claude Sonnet 4 integration

const Anthropic = require('@anthropic-ai/sdk');
const { getService } = require('./services');

// Initialize Anthropic client
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

// Legacy system prompts (fallback for services not in services.js)
const LEGACY_PROMPTS = {
  // Can copy from index.js:31-135 if needed for backward compatibility
  // OR remove entirely if all services are in services.js
};

/**
 * Generate AI response using Claude Sonnet 4
 * @param {string} serviceKey - Service identifier (e.g., "brainstorm", "concept")
 * @param {string} userMessage - User's input prompt
 * @returns {Promise<Object>} AI-generated JSON response
 * @throws {Error} If service not found or AI generation fails
 */
async function generateWithAI(serviceKey, userMessage) {
  // Get service config from services.js
  const service = getService(serviceKey);
  const systemPrompt = service ? service.systemPrompt : LEGACY_PROMPTS[serviceKey];

  if (!systemPrompt) {
    throw new Error(`Unknown service: ${serviceKey}`);
  }

  try {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      system: systemPrompt,
      messages: [
        { role: 'user', content: userMessage }
      ]
    });

    const content = response.content[0].text;

    // Extract JSON from response (Claude may wrap in markdown)
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in AI response');
    }

    return JSON.parse(jsonMatch[0]);

  } catch (error) {
    console.error('AI generation error:', error.message);
    throw error;
  }
}

module.exports = { generateWithAI };
```

**Update**: `src/index.js`

**Replace** lines 140-174 with:
```javascript
const { generateWithAI } = require('./ai');
```

**Keep** existing service route handlers (lines 177-793) — they use generateWithAI but don't need changes

**Update**: `src/hub.js`

**Add import** at top:
```javascript
const { generateWithAI } = require('./ai');
```

**Verification**:
```bash
# Test server starts without errors
node src/index.js
# Should see: "Server running on port 7378"
```

**Checkpoint**: Server starts, no import errors, no circular dependency warnings

**Deliverable**:
- New file: `src/ai.js` with generateWithAI function
- Updated imports in src/index.js and src/hub.js
- Server starts successfully

---

## Task 5: Update Job Status Enum Support

**Objective**: Ensure database and code support "failed" status for jobs

**Why Fifth**: AI processing can fail, need to handle gracefully

**Check**: Does `jobs.status` column allow "failed" value?

**File**: `src/db.js`

**Verify** schema initialization (in `initDB()` function):
```javascript
// Current schema likely has:
status TEXT DEFAULT 'pending'

// Should support: 'pending', 'paid', 'completed', 'failed'
// No CHECK constraint needed (TEXT field is flexible)
```

**If needed**, add comment for clarity:
```javascript
await query(`
  CREATE TABLE IF NOT EXISTS jobs (
    id SERIAL PRIMARY KEY,
    job_uuid TEXT UNIQUE NOT NULL,
    requester_id INTEGER REFERENCES users(id),
    agent_id INTEGER REFERENCES agents(id),
    skill_id INTEGER REFERENCES skills(id),
    status TEXT DEFAULT 'pending',  -- pending | paid | completed | failed
    input_data JSONB,
    output_data JSONB,
    price_usdc NUMERIC(10, 6) NOT NULL,
    payment_tx_hash TEXT,
    payout_tx_hash TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    paid_at TIMESTAMP,
    delivered_at TIMESTAMP,
    completed_at TIMESTAMP
  );
`);
```

**No migration needed** — TEXT fields already support any value

**Verification**:
```bash
# Test creating a failed job
node -e "
const db = require('./src/db');
db.updateJobStatus(1, 'failed', { output_data: JSON.stringify({ error: 'test' }) })
  .then(() => console.log('Failed status works'))
  .catch(e => console.error(e));
"
```

**Deliverable**: Confirmation that "failed" status is supported

---

## Task 6: Add Error Handling and Logging

**Objective**: Improve observability and debugging for AI processing

**Why Sixth**: Production readiness — need to diagnose issues when they occur

**Enhancements**:

**File**: `src/hub.js` (payment endpoint)

**Add structured logging**:
```javascript
// At start of AI processing
console.log(JSON.stringify({
  timestamp: new Date().toISOString(),
  event: 'ai_processing_start',
  jobUuid: job.job_uuid,
  serviceKey: serviceKey,
  inputLength: userInput.length
}));

// After AI completion
console.log(JSON.stringify({
  timestamp: new Date().toISOString(),
  event: 'ai_processing_complete',
  jobUuid: job.job_uuid,
  duration: duration,
  outputSize: JSON.stringify(aiResult).length
}));

// On error
console.error(JSON.stringify({
  timestamp: new Date().toISOString(),
  event: 'ai_processing_error',
  jobUuid: job.job_uuid,
  error: aiError.message,
  stack: aiError.stack
}));
```

**Add timeout protection** (optional but recommended):
```javascript
// Wrap AI call with timeout
const AI_TIMEOUT = 30000; // 30 seconds

const aiResult = await Promise.race([
  generateWithAI(serviceKey, userInput),
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error('AI generation timeout')), AI_TIMEOUT)
  )
]);
```

**Deliverable**:
- Structured logging for AI processing events
- Timeout protection (optional)
- Error details captured for debugging

---

## Task 7: Manual End-to-End Testing

**Objective**: Verify complete flow works in development environment

**Why Last**: Integration testing before marking phase complete

**Test Scenarios**:

### Test 1: Successful Job Processing

**Steps**:
1. Start server: `npm start`
2. Open browser: `http://localhost:7378`
3. Connect MetaMask wallet
4. Select "Brainstorm" service
5. Enter prompt: "Marketing campaign for eco-friendly water bottles"
6. Create job (POST /api/jobs)
7. Pay with USDC (MetaMask transaction)
8. Submit payment (POST /api/jobs/:uuid/pay with txHash)
9. Wait for response (~2-5 seconds)
10. Verify job page shows AI results (GET /job/:uuid)

**Expected**:
- Job status: `completed`
- `output_data` contains JSON with `{ ideas: [...] }`
- Results displayed on job page (not raw JSON)
- Timestamps: `paid_at` and `completed_at` populated

### Test 2: AI Failure Handling

**Steps**:
1. Modify AI function to throw error (temporary):
   ```javascript
   // In src/ai.js, add before API call:
   if (serviceKey === 'brainstorm') {
     throw new Error('Simulated AI failure');
   }
   ```
2. Create and pay for brainstorm job
3. Check response and database

**Expected**:
- Job status: `failed`
- `output_data`: `{ error: 'AI generation failed', message: '...' }`
- HTTP 500 response with error details
- Job remains in database (not deleted)

### Test 3: Invalid Service Key

**Steps**:
1. Manually update skill in database with invalid service_key:
   ```sql
   UPDATE skills SET service_key = 'invalid_service' WHERE id = 1;
   ```
2. Create and pay for job with that skill
3. Check error handling

**Expected**:
- Job status: `failed`
- Error: "Unknown service: invalid_service"
- Proper error response to client

### Test 4: Database Query Performance

**Steps**:
1. Check server logs for query timing
2. Verify AI processing completes in <5 seconds total

**Expected**:
- Payment verification: ~500ms (blockchain RPC call)
- Skill lookup: <50ms (database query)
- AI generation: 1-3 seconds (Anthropic API)
- Status update: <50ms (database write)
- **Total**: 2-5 seconds end-to-end

**Verification Commands**:
```bash
# Check job status in database
psql $DATABASE_URL -c "SELECT job_uuid, status, created_at, paid_at, completed_at FROM jobs ORDER BY created_at DESC LIMIT 5;"

# Check output_data
psql $DATABASE_URL -c "SELECT job_uuid, output_data FROM jobs WHERE status = 'completed' LIMIT 1;"

# Check for failed jobs
psql $DATABASE_URL -c "SELECT job_uuid, status, output_data FROM jobs WHERE status = 'failed';"
```

**Checkpoint**: All 4 test scenarios pass

**Deliverable**:
- Documented test results
- Screenshots of working flow (optional)
- Confirmation that end-to-end flow works

---

</tasks>

<verification>

## Pre-Execution Checklist

Before starting implementation:
- [ ] Phase 2 complete (payment verification working)
- [ ] Database contains seeded skills
- [ ] ANTHROPIC_API_KEY in .env is valid
- [ ] Server starts without errors
- [ ] Can access http://localhost:7378

## Post-Task Checkpoints

### After Task 1 (Discovery)
- [ ] Documented how skills map to services
- [ ] Identified if service_key column exists
- [ ] Decision made on mapping approach

### After Task 2 (Database Helper)
- [ ] `getSkill(skillId)` function exists in src/db.js
- [ ] Function exported in module.exports
- [ ] Tested with sample query (returns skill object)

### After Task 3 (Payment Integration)
- [ ] AI processing code added to payment endpoint
- [ ] Error handling for AI failures implemented
- [ ] Logging statements added

### After Task 4 (Extract AI Module)
- [ ] `src/ai.js` file created
- [ ] Imports updated in src/index.js and src/hub.js
- [ ] Server starts without circular dependency errors
- [ ] No import errors in console

### After Task 5 (Job Status)
- [ ] "failed" status confirmed to work
- [ ] Database schema supports all status values

### After Task 6 (Logging)
- [ ] Structured logging implemented
- [ ] Error logs include job UUID and details
- [ ] (Optional) Timeout protection added

### After Task 7 (Testing)
- [ ] Manual test passed: Job creation → Payment → AI result
- [ ] Results appear on job page
- [ ] `output_data` contains structured JSON
- [ ] Failed job test passed (status = 'failed')
- [ ] End-to-end latency < 5 seconds

## Final Verification Commands

```bash
# 1. Server starts successfully
npm start
# Expected: "Server running on port 7378"

# 2. AI function works standalone
node -e "const { generateWithAI } = require('./src/ai'); generateWithAI('brainstorm', 'test prompt').then(r => console.log(r));"
# Expected: JSON output with ideas

# 3. Database has skills with service keys
psql $DATABASE_URL -c "SELECT id, name, service_key FROM skills LIMIT 5;"
# Expected: 5 skills with service_key column populated

# 4. Payment endpoint accessible
curl http://localhost:7378/api/jobs/test-uuid/pay -X POST -H "Content-Type: application/json" -d '{"txHash":"0x123"}'
# Expected: 404 (job not found) not 500 (server error)

# 5. Recent jobs show completed status
psql $DATABASE_URL -c "SELECT job_uuid, status, output_data IS NOT NULL as has_output FROM jobs ORDER BY created_at DESC LIMIT 3;"
# Expected: At least 1 job with status='completed' and has_output=true
```

## Success Criteria (Final)

All must be true:
- [ ] Payment endpoint triggers AI generation
- [ ] AI results stored in database
- [ ] Job status updates to "completed"
- [ ] Manual test: User can pay and receive results within 5 seconds
- [ ] Error handling: Failed AI jobs marked as "failed"
- [ ] No circular dependency errors
- [ ] Server starts successfully
- [ ] Logs show AI processing events

</verification>

<success_criteria>

## Phase 3 Complete When:

### Functional Requirements ✅
1. **End-to-End Flow Works**:
   - User creates job → Pays with USDC → Receives AI results
   - Results appear on job detail page within 5 seconds
   - Multiple services work (brainstorm, concept, research, etc.)

2. **Database State Correct**:
   - Jobs progress through statuses: `pending` → `paid` → `completed`
   - `output_data` field contains structured JSON
   - Timestamps populated: `created_at`, `paid_at`, `completed_at`

3. **Error Handling Robust**:
   - AI failures result in status = `failed`
   - Error details stored in `output_data`
   - User receives clear error message
   - Job not stuck in limbo

### Technical Requirements ✅
1. **Code Quality**:
   - No circular dependencies
   - AI logic in separate module (`src/ai.js`)
   - Database helper function for skill lookup
   - Structured logging for debugging

2. **Performance**:
   - End-to-end latency < 5 seconds (payment → result)
   - AI generation < 3 seconds average
   - Database queries < 100ms

3. **Security**:
   - No new vulnerabilities introduced
   - Payment verification still works (Phase 2)
   - API key remains server-side

### Testing Requirements ✅
1. **Manual Tests Pass**:
   - Successful job processing (at least 2 different services)
   - AI failure handling
   - Invalid service key handling
   - Performance within acceptable range

2. **Database Verification**:
   - At least 1 completed job in database
   - `output_data` matches expected service schema
   - No orphaned jobs in "paid" status

### Documentation Requirements ✅
1. **Code Comments**:
   - Payment endpoint documents AI integration
   - AI module has JSDoc comments
   - Database helper function documented

2. **Logs**:
   - AI processing events logged with timestamps
   - Errors include job UUID for tracing
   - Performance metrics captured (duration)

## Unblocks

Phase 3 completion unblocks:
- ✅ **Phase 4**: Replicate Image Generation (can build on AI processing flow)
- ✅ **Phase 5**: Results Display & Formatting (have real results to display)
- ✅ **Phase 6**: Agent Webhook System (can trigger webhooks after job completion)
- ✅ **Phase 12**: End-to-End Testing (core flow working)

## Not In Scope (Deferred)

These are explicitly NOT part of Phase 3:
- ❌ Results display formatting (Phase 5)
- ❌ Image generation via Replicate (Phase 4)
- ❌ Agent webhook notifications (Phase 6)
- ❌ Rate limiting (Phase 9)
- ❌ Advanced error recovery (retry logic, etc.)
- ❌ Job queue system (future enhancement)
- ❌ Result caching (future optimization)

</success_criteria>

<output>

## Deliverables

### Code Files Modified
1. **src/ai.js** (NEW) — AI generation module
   - `generateWithAI(serviceKey, userMessage)` function
   - Anthropic SDK integration
   - JSON extraction logic

2. **src/db.js** — Database helpers
   - `getSkill(skillId)` function added
   - Exported in module.exports
   - (Optional) Migration for service_key column

3. **src/hub.js** — Payment endpoint
   - AI processing integration in POST `/api/jobs/:uuid/pay`
   - Error handling for AI failures
   - Structured logging
   - Import `generateWithAI` from src/ai.js

4. **src/index.js** — Main server
   - Import `generateWithAI` from src/ai.js (remove duplicate)
   - No other changes needed

### Database Changes
- (Optional) `service_key` column added to skills table if missing
- (Optional) Existing skills updated with service_key values

### Testing Evidence
- Manual test results documented
- Screenshots or logs showing successful flow
- Database queries confirming output_data populated

### Logs & Metrics
- Structured JSON logs for AI processing events
- Performance metrics (timing per job)
- Error logs with stack traces

## Files to Commit

```bash
git add src/ai.js                  # New AI module
git add src/db.js                  # Added getSkill function
git add src/hub.js                 # Updated payment endpoint
git add src/index.js               # Updated imports

git commit -m "feat(03-01): integrate AI processing into payment flow

- Extract generateWithAI to src/ai.js module
- Add getSkill() database helper
- Wire payment endpoint to trigger AI generation
- Store results in jobs.output_data
- Update status: paid → completed
- Error handling for AI failures (status = failed)
- Structured logging for debugging

Completes Phase 3: Payment → AI Processing Flow

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

## Next Phase Preview

After Phase 3 completion, proceed to:

**Phase 4: Replicate Image Generation Integration**
- Install Replicate SDK
- Wire image services to Replicate API
- Store image URLs in output_data
- Build on existing AI processing flow

**To start**: `/gsd:plan-phase 4`

</output>

---

**Estimated Time**: 2-3 hours
**Complexity**: Medium (integration logic, refactoring)
**Risk Level**: Low (well-defined, no new external dependencies)
**Dependencies**: Phase 2 complete (payment verification)

**Budget Impact**:
- Development: ~$0.50 in API costs for testing (10-15 test jobs)
- Per-job cost: ~$0.005-0.015 Anthropic API fees
- User pricing: $0.10-1.50 per job (healthy margin)

---

*Plan created: 2026-02-03*
*Phase: 3 of 13*
*Mode: YOLO (auto-execute)*
