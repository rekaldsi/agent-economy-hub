# Phase 2 Plan 1: Payment Verification & Security

## Objective

Implement on-chain transaction verification for USDC payments, secure exposed API keys by moving blockchain operations to backend, add input validation to API endpoints, and prevent XSS vulnerabilities.

**Success**: Payment transactions verified on Base blockchain, Alchemy API key secured server-side, user inputs validated, XSS attack surface eliminated.

---

## Execution Context

**Phase**: 2 of 13 — Payment Verification & Security
**Milestone**: Launch v1.0
**Complexity**: Medium (blockchain integration + security hardening)
**Estimated Time**: 2-3 hours

**Prior Context**:
- Phase 1 complete: Dependencies installed, environment configured, server running
- Database seeded with MrMagoochi agent + 22 skills
- Current payment flow: client-side only, no verification
- Alchemy API key exposed in client-side code (hub.js:288)

**Codebase References**:
- @.planning/codebase/CONCERNS.md (Issues #4, #5, #7, #8, #9)
- @.planning/codebase/INTEGRATIONS.md (Blockchain integration, payment processing)
- @.planning/phases/01-environment-setup/01-01-SUMMARY.md (Phase 1 results)

---

## Context

### Current State

**Payment Flow (Client-Side Only)**:
1. User pays with USDC via MetaMask → `ethers.js` in browser
2. Transaction hash returned from blockchain
3. POST `/api/jobs/:uuid/pay` with `{txHash}`
4. **Backend blindly trusts txHash** ⚠️ No verification
5. Job status updated to "paid"

**Security Issues**:
```javascript
// src/hub.js:1527-1541 - Current implementation
router.post('/api/jobs/:uuid/pay', async (req, res) => {
  const { txHash } = req.body;  // ← TRUSTS CLIENT INPUT
  await db.updateJobStatus(job.id, 'paid', {
    payment_tx_hash: txHash,  // ← NO VERIFICATION
    paid_at: new Date()
  });
  res.json({ status: 'paid', txHash });
});
```

**Exposed API Key**:
```javascript
// src/hub.js:288 - Client-side code
rpcUrls: ['https://base-mainnet.g.alchemy.com/v2/GMcDISyWWgpZWJai3DjVZ']
//                                                  ^^^^^^^^^^^^^^^^
//                                                  Exposed to all users
```

**Other Vulnerabilities**:
- No input validation (SQL injection risk in updateJobStatus)
- XSS vulnerabilities (unsanitized HTML rendering)
- No wallet address format validation
- No authentication/authorization checks

### What We're Building

**Backend Blockchain Service** (`src/blockchain.js`):
- Server-side ethers.js provider with secured Alchemy key
- Transaction verification functions
- USDC contract interaction
- Payment amount validation

**Payment Verification Logic**:
1. Receive txHash from client
2. **Verify transaction exists on-chain**
3. **Verify transaction succeeded (not reverted)**
4. **Verify payment amount matches job price**
5. **Verify recipient is correct agent wallet**
6. Only then mark job as "paid"

**Input Validation**:
- Ethereum address format validation
- Price validation (positive numbers)
- SQL injection prevention
- HTML sanitization

---

## Tasks

### Task 1: Create Backend Blockchain Service

**Goal**: Move blockchain operations to backend with secured API access

**Steps**:
1. Create `src/blockchain.js` module
2. Initialize ethers provider with Alchemy RPC (using env var)
3. Create USDC contract instance (Base network)
4. Implement helper functions:
   - `getTransaction(txHash)` - Fetch transaction from blockchain
   - `verifyUSDCPayment(txHash, expectedAmount, recipientAddress)` - Full verification
   - `getUSDCBalance(address)` - Check balance (for future use)

**Implementation**:
```javascript
// src/blockchain.js
const { ethers } = require('ethers');

const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
const BASE_RPC_URL = `https://base-mainnet.g.alchemy.com/v2/${process.env.ALCHEMY_API_KEY}`;

const provider = new ethers.JsonRpcProvider(BASE_RPC_URL);

const USDC_ABI = [
  'function transfer(address to, uint256 amount) returns (bool)',
  'function balanceOf(address account) view returns (uint256)',
  'function decimals() view returns (uint8)'
];

const usdcContract = new ethers.Contract(USDC_ADDRESS, USDC_ABI, provider);

async function getTransaction(txHash) {
  try {
    const tx = await provider.getTransaction(txHash);
    if (!tx) return null;

    const receipt = await provider.getTransactionReceipt(txHash);
    return { tx, receipt };
  } catch (error) {
    console.error('Error fetching transaction:', error.message);
    return null;
  }
}

async function verifyUSDCPayment(txHash, expectedAmountUSDC, recipientAddress) {
  const result = await getTransaction(txHash);
  if (!result) {
    return { valid: false, error: 'Transaction not found' };
  }

  const { tx, receipt } = result;

  // 1. Check transaction succeeded
  if (receipt.status !== 1) {
    return { valid: false, error: 'Transaction failed (reverted)' };
  }

  // 2. Check transaction is to USDC contract
  if (tx.to.toLowerCase() !== USDC_ADDRESS.toLowerCase()) {
    return { valid: false, error: 'Transaction not to USDC contract' };
  }

  // 3. Decode transfer data
  const iface = new ethers.Interface(USDC_ABI);
  let decodedData;
  try {
    decodedData = iface.parseTransaction({ data: tx.data });
  } catch (e) {
    return { valid: false, error: 'Could not decode transaction data' };
  }

  if (decodedData.name !== 'transfer') {
    return { valid: false, error: 'Transaction is not a transfer' };
  }

  const [to, amount] = decodedData.args;

  // 4. Check recipient matches
  if (to.toLowerCase() !== recipientAddress.toLowerCase()) {
    return { valid: false, error: `Payment sent to wrong address: ${to}` };
  }

  // 5. Check amount (USDC has 6 decimals)
  const amountUSDC = Number(amount) / 1e6;
  const expectedAmount = Number(expectedAmountUSDC);

  // Allow 0.1% tolerance for rounding
  const tolerance = expectedAmount * 0.001;
  if (Math.abs(amountUSDC - expectedAmount) > tolerance) {
    return {
      valid: false,
      error: `Amount mismatch: expected ${expectedAmount}, got ${amountUSDC}`
    };
  }

  return {
    valid: true,
    amount: amountUSDC,
    from: tx.from,
    to,
    blockNumber: receipt.blockNumber
  };
}

async function getUSDCBalance(address) {
  try {
    const balance = await usdcContract.balanceOf(address);
    const decimals = await usdcContract.decimals();
    return Number(balance) / 10**Number(decimals);
  } catch (error) {
    console.error('Error fetching balance:', error.message);
    return null;
  }
}

module.exports = {
  getTransaction,
  verifyUSDCPayment,
  getUSDCBalance,
  USDC_ADDRESS
};
```

**Expected Output**:
- New file: `src/blockchain.js` (~120 lines)
- Alchemy key moved from client to server
- Transaction verification logic implemented

**Checkpoint**: Backend blockchain service created

**Files Created**: `src/blockchain.js`

---

### Task 2: Update Payment Endpoint with Verification

**Goal**: Modify POST /api/jobs/:uuid/pay to verify transactions on-chain

**Steps**:
1. Import blockchain service in `src/hub.js`
2. Update payment endpoint to verify transaction before accepting
3. Fetch job and skill details to get expected price and agent wallet
4. Call `verifyUSDCPayment()` with transaction details
5. Only update job status if verification passes
6. Return detailed error messages for failed verifications

**Implementation**:
```javascript
// src/hub.js - Add import at top
const blockchain = require('./blockchain.js');

// Update payment endpoint (lines 1527-1543)
router.post('/api/jobs/:uuid/pay', async (req, res) => {
  try {
    const { txHash } = req.body;

    // Validate input
    if (!txHash || typeof txHash !== 'string' || !txHash.startsWith('0x')) {
      return res.status(400).json({ error: 'Invalid transaction hash' });
    }

    const job = await db.getJob(req.params.uuid);
    if (!job) return res.status(404).json({ error: 'Job not found' });

    if (job.status !== 'pending') {
      return res.status(400).json({ error: `Job status is ${job.status}, cannot accept payment` });
    }

    // Get agent details for wallet address
    const agent = await db.getAgent(job.agent_id);
    if (!agent) return res.status(500).json({ error: 'Agent not found' });

    // Get agent's user record for wallet address
    const agentUser = await db.query(
      'SELECT wallet_address FROM users WHERE id = $1',
      [agent.user_id]
    );
    if (!agentUser.rows[0]) {
      return res.status(500).json({ error: 'Agent wallet not found' });
    }

    const agentWallet = agentUser.rows[0].wallet_address;

    // Verify payment on-chain
    console.log(`Verifying payment: txHash=${txHash}, amount=${job.price_usdc}, recipient=${agentWallet}`);

    const verification = await blockchain.verifyUSDCPayment(
      txHash,
      job.price_usdc,
      agentWallet
    );

    if (!verification.valid) {
      console.error('Payment verification failed:', verification.error);
      return res.status(400).json({
        error: 'Payment verification failed',
        details: verification.error
      });
    }

    console.log('Payment verified:', verification);

    // Update job status
    const updated = await db.updateJobStatus(job.id, 'paid', {
      payment_tx_hash: txHash,
      paid_at: new Date()
    });

    // TODO: Trigger agent webhook / process job (Phase 3)

    res.json({
      status: 'paid',
      txHash,
      verified: true,
      amount: verification.amount,
      blockNumber: verification.blockNumber
    });
  } catch (error) {
    console.error('Payment endpoint error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

**Expected Output**:
- Payment endpoint verifies transactions before accepting
- Invalid/fake transactions rejected
- Detailed error messages for debugging

**Checkpoint**: Payment verification working

**Files Modified**: `src/hub.js:1527-1543` (payment endpoint)

---

### Task 3: Remove Exposed Alchemy Key from Client

**Goal**: Remove hardcoded Alchemy API key from client-side JavaScript

**Steps**:
1. Update `src/hub.js` client-side code (HUB_SCRIPTS)
2. Remove Alchemy RPC URL from network addition code
3. Use only public Base RPC endpoint for client-side operations
4. Update network switching logic to use public RPC

**Implementation**:
```javascript
// src/hub.js:288 - Update to use public RPC only
rpcUrls: ['https://mainnet.base.org'],  // ← Public RPC, no API key
blockExplorerUrls: ['https://basescan.org']
```

**Note**: Client-side wallet operations (MetaMask) don't actually need custom RPC - MetaMask uses its own providers. The RPC URL is only for the `wallet_addEthereumChain` call.

**Expected Output**:
- Alchemy API key removed from client code
- No functionality broken (MetaMask handles RPC)

**Checkpoint**: API key secured

**Files Modified**: `src/hub.js:288` (remove Alchemy URL)

---

### Task 4: Add Input Validation Middleware

**Goal**: Validate user inputs to prevent injection attacks and bad data

**Steps**:
1. Add wallet address validation helper
2. Add price validation helper
3. Update POST /api/jobs endpoint with validation
4. Fix SQL injection risk in updateJobStatus (whitelist fields)

**Implementation**:
```javascript
// src/hub.js - Add validation helpers after imports

function isValidEthereumAddress(address) {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}

function isValidPrice(price) {
  const num = Number(price);
  return !isNaN(num) && num > 0 && num < 1000; // Max $1000 per job
}

// Update POST /api/jobs (lines 1504-1524)
router.post('/api/jobs', async (req, res) => {
  try {
    const { wallet, agentId, skillId, input, price } = req.body;

    // Validate required fields
    if (!wallet || !agentId || !skillId || !input) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Validate wallet address format
    if (!isValidEthereumAddress(wallet)) {
      return res.status(400).json({ error: 'Invalid wallet address format' });
    }

    // Validate price
    if (!isValidPrice(price)) {
      return res.status(400).json({ error: 'Invalid price (must be positive number < $1000)' });
    }

    // Validate IDs are positive integers
    if (!Number.isInteger(agentId) || agentId <= 0) {
      return res.status(400).json({ error: 'Invalid agent ID' });
    }
    if (!Number.isInteger(skillId) || skillId <= 0) {
      return res.status(400).json({ error: 'Invalid skill ID' });
    }

    // Verify agent exists
    const agent = await db.getAgent(agentId);
    if (!agent || !agent.is_active) {
      return res.status(404).json({ error: 'Agent not found or inactive' });
    }

    // Get or create user
    let user = await db.getUser(wallet);
    if (!user) {
      user = await db.createUser(wallet, 'human');
    }

    const jobUuid = uuidv4();
    const job = await db.createJob(jobUuid, user.id, agentId, skillId, { prompt: input }, price);

    res.json({ jobUuid: job.job_uuid, status: job.status });
  } catch (error) {
    console.error('Job creation error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

**Fix SQL Injection in updateJobStatus**:
```javascript
// src/db.js:192-208 - Whitelist allowed fields
async function updateJobStatus(jobId, status, extraFields = {}) {
  const allowedFields = [
    'payment_tx_hash',
    'payout_tx_hash',
    'paid_at',
    'delivered_at',
    'completed_at',
    'output_data'
  ];

  const setClauses = ['status = $1'];
  const params = [status];
  let paramIndex = 2;

  for (const [key, value] of Object.entries(extraFields)) {
    // Whitelist check prevents SQL injection
    if (!allowedFields.includes(key)) {
      console.warn(`Ignoring invalid field: ${key}`);
      continue;
    }

    setClauses.push(`${key} = $${paramIndex}`);
    params.push(value);
    paramIndex++;
  }

  params.push(jobId);

  const query = `
    UPDATE jobs
    SET ${setClauses.join(', ')}, updated_at = NOW()
    WHERE id = $${paramIndex}
    RETURNING *
  `;

  const result = await pool.query(query, params);
  return result.rows[0];
}
```

**Expected Output**:
- Invalid inputs rejected with clear error messages
- SQL injection prevented via field whitelist
- Agent existence verified before job creation

**Checkpoint**: Input validation working

**Files Modified**:
- `src/hub.js:1504-1524` (job creation endpoint)
- `src/db.js:192-208` (updateJobStatus function)

---

### Task 5: Prevent XSS Vulnerabilities

**Goal**: Sanitize user-generated content before rendering as HTML

**Steps**:
1. Identify XSS-prone areas (job output display, user names, prompts)
2. Use `textContent` instead of `innerHTML` where possible
3. Escape HTML special characters for dynamic content
4. Add Content-Security-Policy header

**Implementation**:
```javascript
// src/hub.js - Add HTML sanitization helper
function escapeHtml(unsafe) {
  if (!unsafe) return '';
  return unsafe
    .toString()
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// Update job detail page (lines 1393-1399) - Example fix
<div class="result">
  <pre id="job-output"></pre>
  <script>
    const output = ${JSON.stringify(job.output_data || {})};
    document.getElementById('job-output').textContent = JSON.stringify(output, null, 2);
  </script>
</div>

// Add CSP header in src/index.js (after app initialization)
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com"
  );
  next();
});
```

**Note**: Since HTML is embedded in routes, complete XSS prevention requires careful review of all template literals. Focus on:
- Job output display (line 1393-1399)
- User/agent names (line 1315)
- Input prompts in dashboard

**Expected Output**:
- User-generated content cannot inject scripts
- CSP header blocks unauthorized script execution

**Checkpoint**: XSS vulnerabilities mitigated

**Files Modified**:
- `src/hub.js` (multiple HTML rendering sections)
- `src/index.js` (add CSP header)

---

## Verification

### Automated Checks

```bash
# Check blockchain service exists
test -f src/blockchain.js && echo "✅ Blockchain service created" || echo "❌ Missing blockchain.js"

# Check Alchemy key not in client code
! grep -r "GMcDISyWWgpZWJai3DjVZ" src/hub.js && echo "✅ Alchemy key removed from client" || echo "❌ Alchemy key still exposed"

# Check validation helpers exist
grep -q "isValidEthereumAddress" src/hub.js && echo "✅ Validation helpers added" || echo "❌ Missing validation"

# Check SQL injection fix
grep -q "allowedFields" src/db.js && echo "✅ SQL injection fixed" || echo "❌ SQL injection not fixed"

# Test blockchain service (requires running node)
node -e "require('dotenv').config(); const bc = require('./src/blockchain.js'); console.log('✅ Blockchain service loads');" 2>&1
```

### Manual Testing Checklist

#### Payment Verification
- [ ] Create test job via API
- [ ] Submit real USDC transaction hash
- [ ] Verify backend validates transaction on-chain
- [ ] Test with fake transaction hash (should reject)
- [ ] Test with transaction to wrong address (should reject)
- [ ] Test with wrong amount (should reject)

#### Input Validation
- [ ] Try invalid wallet address → should return 400
- [ ] Try negative price → should return 400
- [ ] Try non-existent agent ID → should return 404
- [ ] Try SQL injection in extraFields → should be blocked

#### XSS Prevention
- [ ] Submit job with `<script>alert('XSS')</script>` in prompt
- [ ] Check job detail page doesn't execute script
- [ ] Verify HTML is escaped in output

---

## Success Criteria

### Phase 2 Complete When:
- [x] Backend blockchain service created (`src/blockchain.js`)
- [x] Payment verification implemented (on-chain transaction check)
- [x] Alchemy API key removed from client-side code
- [x] Input validation added to API endpoints
- [x] SQL injection vulnerability fixed
- [x] XSS vulnerabilities mitigated
- [x] Manual testing passes for all verification scenarios

### Unblocks:
- ✅ **Phase 3**: Payment → AI Processing Flow (payments now verified, safe to process)
- ✅ **Phase 4**: Replicate Image Generation (secure foundation)
- ✅ All subsequent phases (security baseline established)

---

## Output

### Files Created
- `src/blockchain.js` — Backend blockchain service with transaction verification

### Files Modified
- `src/hub.js:1527-1543` — Payment endpoint with verification
- `src/hub.js:288` — Removed exposed Alchemy key
- `src/hub.js:1504-1524` — Job creation with input validation
- `src/hub.js` — Added validation helpers, HTML escaping
- `src/db.js:192-208` — SQL injection fix (field whitelist)
- `src/index.js` — Added CSP header

### Database Changes
- None (schema unchanged)

---

## Troubleshooting Guide

### Problem: Transaction verification fails for valid transactions

**Symptoms**: "Transaction not found" or timeout errors

**Solutions**:
1. Check ALCHEMY_API_KEY is set in .env
2. Verify Alchemy RPC URL is correct for Base network
3. Check transaction actually exists on Basescan
4. Increase timeout if blockchain is slow
5. Add retry logic for transient failures

---

### Problem: Payment rejected with "Amount mismatch"

**Symptoms**: Verification fails even though amounts look correct

**Solutions**:
1. Check USDC has 6 decimals (not 18 like ETH)
2. Verify job price stored correctly in database
3. Check for rounding errors (tolerance set to 0.1%)
4. Log actual vs expected amounts for debugging

---

### Problem: Alchemy rate limits hit

**Symptoms**: "429 Too Many Requests" errors

**Solutions**:
1. Implement request caching (store verified transactions)
2. Add rate limiting on payment endpoint
3. Consider upgrading Alchemy plan
4. Fall back to public RPC (slower but free)

---

## Notes

- **YOLO Mode**: This plan will auto-execute without manual approval checkpoints
- **Budget**: Alchemy RPC calls are free tier (300M compute units/month)
- **Security Priority**: These fixes are critical before accepting real payments
- **Time Estimate**: 2-3 hours for implementation and testing

---

## Next Steps

After Phase 2 completion:

**Immediate**: `/gsd:plan-phase 3` (Payment → AI Processing Flow)

**Then**: Connect payment verification to actual AI job processing

---

*Created: 2026-02-03*
*Phase: 2 of 13*
*Estimated time: 2-3 hours*
